from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
from werkzeug.security import generate_password_hash, check_password_hash
import os
import jwt as PyJWT
from datetime import datetime, timedelta
# Import your other modules here
import pandas as pd
import json
from datetime import date
 # Add this at the top with other imports


app = Flask(__name__)

# Configure CORS globally
CORS(app, resources={
    r"/*": {
        "origins": ["http://host:3173", "http://localhost:5173"],
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"],
        "expose_headers": ["Content-Type", "Authorization"],
        "supports_credentials": True,
        "max_age": 3600  # Cache preflight requests for 1 hour
    },

})

# Security configurations
app.config['SECRET_KEY'] = os.urandom(24)
STORED_PASSWORD_HASH = generate_password_hash('SimpleM@th')

# Remove the custom CORS headers function since flask-cors handles this
def add_cors_headers(response):
    return response

# Authentication endpoints
@app.route('/api/verify-password', methods=['POST', 'OPTIONS'])
def verify_password():
    if request.method == 'OPTIONS':
        response = jsonify({'status': 'ok'})
        return add_cors_headers(response), 204
    
    data = request.get_json()
    if not data or 'password' not in data:
        return jsonify({'error': 'Password required'}), 400
    
    if check_password_hash(STORED_PASSWORD_HASH, data['password']):
        token = PyJWT.encode({
            'exp': datetime.utcnow() + timedelta(hours=24)
        }, app.config['SECRET_KEY'], algorithm='HS256')
        
        response = jsonify({
            'message': 'Authentication successful',
            'token': token
        })
        return add_cors_headers(response), 200
    
    return jsonify({'error': 'Invalid password'}), 401

@app.route('/api/verify-token', methods=['POST', 'OPTIONS'])
def check_token():
    if request.method == 'OPTIONS':
        response = jsonify({'status': 'ok'})
        return add_cors_headers(response), 204
    
    data = request.get_json()
    if not data or 'token' not in data:
        return jsonify({'error': 'Token required'}), 400
    
    try:
        PyJWT.decode(data['token'], app.config['SECRET_KEY'], algorithms=['HS256'])
        response = jsonify({'valid': True})
        return add_cors_headers(response), 200
    except:
        response = jsonify({'valid': False})
        return add_cors_headers(response), 401

# Data endpoints
@app.route('/')
def index():
    return jsonify({})

@app.route('/get_trades')
def get_trades():
    print("Getting trades")
    try:
        # Use the split-adjusted file instead of the original
        file_path = os.path.join(os.path.dirname(__file__), 'split_adjusted_MIM.csv')
        print(f"Attempting to open file at: {file_path}")
        
        if not os.path.exists(file_path):
            print(f"File not found at: {file_path}")
            return jsonify({'error': 'Trade file not found'}), 404
            
        # Read CSV with pandas
        df = pd.read_csv(file_path)
        df.fillna('', inplace=True)
        
        # Convert DataFrame to list of dictionaries
        data = df.to_dict('records')
        
        print(f"Successfully read {len(data)} trades")
        return jsonify({'trades': data})
        
    except Exception as e:
        print(f"Error reading trades: {str(e)}")
        response = jsonify({'error': f'Failed to read trades: {str(e)}'})
        return add_cors_headers(response), 500

def get_splits_for_symbol(symbol):
    """Get all stock splits for a symbol from the CSV file."""
    try:
        file_path = os.path.join(os.path.dirname(__file__), f'AllETNS/{symbol}.csv')
        if not os.path.exists(file_path):
            return []
        
        df = pd.read_csv(file_path)
        if 'Stock Splits' not in df.columns or 'Date' not in df.columns:
            return []
        
        # Filter for non-zero splits and sort by date descending
        splits_df = df[df['Stock Splits'] != 0][['Date', 'Stock Splits']]
        splits_df['Date'] = pd.to_datetime(splits_df['Date'], utc=True)
        splits_df = splits_df.sort_values('Date', ascending=False)
        
        # Convert to list of dictionaries
        splits = [
            {'date': row['Date'].strftime('%Y-%m-%d'), 'ratio': row['Stock Splits']}
            for _, row in splits_df.iterrows()
        ]
        
        return splits
        
    except Exception as e:
        print(f"Error getting splits for {symbol}: {str(e)}")
        return []

def calculate_split_factor(splits, trade_date):
    """Calculate cumulative split factor for splits after the trade date."""
    trade_date = pd.to_datetime(trade_date, utc=True)
    cumulative_factor = 1
    
    for split in splits:
        split_date = pd.to_datetime(split['date'], utc=True)
        if split_date >= trade_date:
            # For splits after trade date, multiply by the split ratio
            cumulative_factor *= split['ratio']
    
    return cumulative_factor

@app.route('/get_symbol_data', methods=['GET'])
def get_symbol_data():
    symbol = request.args.get('symbol')
    if not symbol:
        return jsonify({'error': 'Symbol is required'}), 400
    
    file_path = os.path.join(os.path.dirname(__file__), f'AllETNS/{symbol}.csv')
    if not os.path.exists(file_path):
        return jsonify({'error': f'File for symbol {symbol} not found'}), 404
    
    try:
        # Read the CSV file
        df = pd.read_csv(file_path)
        
        # Verify required column exists
        if 'Date' not in df.columns:
            return jsonify({'error': f'Invalid CSV format: Missing Date column'}), 500
        
        # Convert dates and filter, catching potential date conversion errors
        try:
            df['Date'] = pd.to_datetime(df['Date'], errors='raise', utc=True)
        except Exception as date_error:
            return jsonify({'error': f'Invalid date format in CSV: {str(date_error)}'}), 500
            
        df = df[df['Date'].dt.year >= 2022]
        
        # Check if we have any data left after filtering
        if df.empty:
            return jsonify({'error': f'No data found for {symbol} from 2022 onwards'}), 404
            
        df['Date'] = df['Date'].dt.strftime('%Y-%m-%d')
        data = df.to_dict('records')
        return jsonify(data)
        
    except pd.errors.EmptyDataError:
        return jsonify({'error': f'CSV file for {symbol} is empty'}), 500
    except pd.errors.ParserError as e:
        return jsonify({'error': f'Failed to parse CSV file: {str(e)}'}), 500
    except Exception as e:
        return jsonify({'error': f'Failed to process data for symbol {symbol}: {str(e)}'}), 500


@app.route('/add_trade', methods=['POST'])
def add_trade():
    try:
        data = request.get_json()
        required_fields = ['Date of Trade', 'Action', 'Symbol', 'Description', 
                          'Type', 'Quantity', 'Price ($)', 'Commission ($)', 
                          'Fees ($)', 'Accrued Interest ($)', 'Amount ($)', 
                          'Cash Balance ($)', 'Settlement Date']
        
        # Validate all required fields are present
        for field in required_fields:
            if field not in data:
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        file_path = os.path.join(os.path.dirname(__file__), 'split_adjusted_MIM.csv')
        
        # First, check if we need to add a newline
        with open(file_path, 'r') as f:
            f.seek(0, 2)  # Seek to end of file
            if f.tell() > 0:  # If file is not empty
                f.seek(f.tell() - 1)  # Go to last character
                last_char = f.read(1)
                needs_newline = last_char != '\n'

        # If needed, add a newline before appending
        if needs_newline:
            with open(file_path, 'a') as f:
                f.write('\n')

        # Create a single-row DataFrame and append to CSV
        new_trade_df = pd.DataFrame([data], columns=required_fields)
        new_trade_df.to_csv(file_path, mode='a', header=False, index=False)
            
        return jsonify({'message': 'Trade added successfully'}), 200
        
    except Exception as e:
        print(f"Error adding trade: {str(e)}")
        return jsonify({'error': f'Failed to add trade: {str(e)}'}), 500


@app.route('/get_stock_splits', methods=['GET'])
def get_stock_splits():
    symbol = request.args.get('symbol')
    if not symbol:
        return jsonify({'error': 'Symbol is required'}), 400
    
    file_path = os.path.join(os.path.dirname(__file__), f'AllETNS/{symbol}.csv')
    if not os.path.exists(file_path):
        return jsonify({'error': f'File for symbol {symbol} not found'}), 404
    
    try:
        # Read the CSV file
        df = pd.read_csv(file_path)
        
        # Verify required columns exist
        required_columns = ['Date', 'Stock Splits']
        if not all(col in df.columns for col in required_columns):
            return jsonify({'error': 'Invalid CSV format: Missing required columns'}), 500
        
        # Filter for non-zero stock splits and convert to desired format
        splits_df = df[df['Stock Splits'] != 0][['Date', 'Stock Splits']]
        
        # Convert to list of dictionaries with renamed column
        splits_data = [
            {'date': row['Date'], 'stock_split': row['Stock Splits']} 
            for _, row in splits_df.iterrows()
        ]
        
        return jsonify(splits_data)
        
    except Exception as e:
        return jsonify({'error': f'Failed to process stock splits for symbol {symbol}: {str(e)}'}), 500

@app.route('/delete_trade', methods=['DELETE'])
def delete_trade():
    try:
        data = request.get_json()
        if not data or 'trade_date' not in data or 'symbol' not in data:
            return jsonify({'error': 'Trade date and symbol are required'}), 400
            
        file_path = os.path.join(os.path.dirname(__file__), 'split_adjusted_MIM.csv')
        
        # Read the CSV file
        df = pd.read_csv(file_path)
        
        # Find the trade to delete
        mask = (df['Date of Trade'] == data['trade_date']) & (df['Symbol'] == data['symbol'])
        if not mask.any():
            return jsonify({'error': 'Trade not found'}), 404
            
        # Remove the trade
        df = df[~mask]
        
        # Save the updated CSV
        df.to_csv(file_path, index=False)
        
        return jsonify({'message': 'Trade deleted successfully'}), 200
        
    except Exception as e:
        print(f"Error deleting trade: {str(e)}")
        return jsonify({'error': f'Failed to delete trade: {str(e)}'}), 500

@app.route('/update_trade', methods=['PUT'])
def update_trade():
    try:
        data = request.get_json()
        if not data or 'trade_date' not in data or 'symbol' not in data:
            return jsonify({'error': 'Trade date and symbol are required'}), 400
            
        file_path = os.path.join(os.path.dirname(__file__), 'split_adjusted_MIM.csv')
        
        # Read the CSV file
        df = pd.read_csv(file_path)
        
        # Find the trade to update
        mask = (df['Date of Trade'] == data['original_trade_date']) & (df['Symbol'] == data['original_symbol'])
        if not mask.any():
            return jsonify({'error': 'Trade not found'}), 404
            
        # Update the trade
        for key, value in data.items():
            if key not in ['original_trade_date', 'original_symbol']:
                df.loc[mask, key] = value
        
        # Save the updated CSV
        df.to_csv(file_path, index=False)
        
        return jsonify({'message': 'Trade updated successfully'}), 200
        
    except Exception as e:
        print(f"Error updating trade: {str(e)}")
        return jsonify({'error': f'Failed to update trade: {str(e)}'}), 500

# Error handlers
@app.errorhandler(404)
def not_found(error):
    response = jsonify({'error': 'Not found'})
    return add_cors_headers(response), 404

@app.errorhandler(500)
def internal_error(error):
    response = jsonify({'error': 'Internal server error'})
    return add_cors_headers(response), 500

if __name__ == '__main__':
    app.run(debug=True)